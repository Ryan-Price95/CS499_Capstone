# Ryan Price
## CS-499 Capstone 

## Professional Self-Assessment
Completing my coursework throughout the computer science program at Southern New Hampshire University helped build me into the developer that I am today. Throughout the degree, I have developed a strong foundation in programming, software engineering, cybersecurity, and emerging technologies. These experiences helped me to grow and have shaped my professional values (security minded, collaborative, and always striving to do and learn more) to become a well-rounded developer ready to deliver reliable, efficient, and ethical solutions in the real world. 

### Course Outcome 1: Employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science
Collaboration was essential throughout my degree, but most noticeably in CS 250: Software Development Lifecycle, where we went through all major roles within a Scrum team. I learned how to gather and understand requirements, prioritize backlog items, and maintain open communication with stakeholders throughout the project lifecycle. These skills carried over into courses like CS 320: Software Testing, Automation, and Quality Assurance, where I coordinated test planning and implementation. Throughout these courses, among others, I learned the importance of open and clear communication, whether with stakeholders or with coworkers, and implemented this communication through team-based projects, both throughout school and in my personal, professional life. 

### Course Outcome 2: Design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound, and appropriately adapted to specific audiences and contexts
Following the theme of clear communication, this was vital in demonstrating technical expertise to a range of audiences. In CS 465: Full-Stack Development, I produced both written documentation and visual diagrams to describe the design and functionality of the Travlr Getaways web application. Similarly, in this Capstone course, I created this professional ePortfolio, as well as a detailed README to describe the functionality and implementation of the full CMake inventory application. Continuing, throughout my college career, I have needed to create detailed UML diagrams and presentation materials that refined my ability to communicate complex ideas in an accessible way. 

### Course Outcome 3: Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs in design choices
A strong understanding of algorithms and data structures has shaped how I approach software design and optimization. In CS 260: Data Structures and Algorithms, I implemented Binary Search Trees, hash tables, and vectors to explore how algorithmic efficiency impacts performance. Through this, I learned to asses the trade-offs between time and space complexity and to justify my design decisions based on measurable outcomes. Later, I applied these through CS 350: Emerging Systems Architectures and Technologies, where I learned about AI and ML models as well as the algorithms that make them work, building a treasure hunt pirate game where an agent traveled through a course to find the treasure. 

### Course Outcome 4: Demonstrate and ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals
My coursework allowed me to eplore modern tools and technologies across multiple computing domains. In CS 360: Mobile Architecture and Programming, I built an Android Inventory application that demonstrated CRUD functionality and local database storage. Additionally, in CS 330: Computational Graphics and Visualization, I used OpenGL to create visualizations that could be used for detailed graphical needs. Throughout the entirety of my college career, I have used GitHub (and Git in CS 465: Full-Stack Development) to contain and present various projects, various unit testing frameworks, as well as dependency-check tools to maintain professional coding standards. By continuously learning about new tools and innovative approaches, I am able to keep up with this continuously growing technical world. 

### Course Outcome 5: Develop a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources
Security, throughout this program, has become a defining pillar of my professional identity. In CS 405: Secure Coding, I learned to integrate security at every level of development by implementing encryption algorithms such as AES-256 and SHA-256, managing digital certificates, and conducting secure code reviews. Additionally, in courses like CS 410: Reverse Software Engineering, I deepened my understanding of what software vulnerabilities can appear and behave, as well as how to address and mitigate security concerns, again in CS 405: Secure Coding. 

### Artifacts
My ePortfolio collectively showcases these five outcomes in action. My code review shows my ability to communicate, collaborate, and apply security-minded evaluation, the portfolio itself and the README for my CMake application showcases my ability to design and deliver professional-quality communications, and the application itself showcases outcomes 3, 4, and 5. Demonstrating an integration of algorithmic design principles and managing trade-offs through the implementation of a search feature, the use of techniques and technologies such as wxWidgets for my GUI, and designing with a security mindset by implementing a login feature and ensuring access is limited beyond that. 


## Original Artifact
For this entire project, I decided to use just a single artifact to enhance in the three expected ways, a software development, algorithms, and databases. The artifact that I chose to enhance was from CS 360 where we were tasked with building an Android application that would allow users to log in, access information about the existing inventory, as well as update, add, and remove any inventory from the system. This was built using Android Studio with Java utilizing a SQLite database. 

### See my code review for this artifact:
[CS 360 Code Review](https://youtu.be/HL2QN95b1Kg)

### See my original code for this artifact:
[CS 360 Inventory Application](https://github.com/Ryan-Price95/CS-360)

### Github for my enhanced C++ desktop application:
[Enhanced Desktop Application](https://github.com/Ryan-Price95/InventoryApp_CMake)

## Enhancement One: Software Design and Engineering
For this enhancement, I converted my original Android Inventory App into a C++ desktop application using wxWidgets for the graphical user interface (GUI) and MongoDB for the backend database. This project showcases my skills with designing and implementing software solutions in various platforms while applying the principles of software engineering, system design, and secure coding. The Android version showed my skills in mobile development and SQLite integration, while this enhanced desktop version shows my abilities with C++ to build a fully functional desktop application. 

This enhancement aligns with course outcomes 3, 4, and 5. I aligned with outcome 3 shows through the migration of the app's architecture, implementing a computing solution that applies algorithmic principles and standards, outcome 4 through utilizing innovative tools and frameworks, such as wxWidgets, while outcome 5 shows through the incorporation of proper input validation and database access controls. The project also showcases my ability to make realistic design trade-offs when transitioning between mobile and desktop environments.

This process was rather challenging for me, to be completely honest. I had very limited experience in building a desktop application. wxWidgets is quite different from Android's XML-based layout system. Through trial (and lots of errors), documentation review, and debugging efforts, I created a consistent interface that will adjust to window resizing while still being farily user-friendly. Additionally, implementing real-time CRUD functionality made me rethink how the application handled operations and memory management compared to Java's garbage-collected environment.

## Enhancement Two: Algorithms and Data Structures
For this enhancement, I chose to continue work on converting my Android Inventory Application to the desktop, since the original artifact contained no search functionality. I implemented a search capability within the repository layer of my inventory application, allowing users to locate items by SKU using regular expressions (regex) for flexibility matching. The data handling logic relies on C++ collections and vectors, efficiently storing and retrieving inventory objects from the MongoDB database before they can be displayed in the GUI. I chose regex filtering because it offers a powerful and dynamic way to handle real-world search patterns since regex filtering allows for partial matches, case-insensitive searches, and pattern flexibility. This would be huge for searching based on the name of the item versus just the SKU (a future enhancement that I would love to make). The trade-off is that regex can be computationally heavier on lage datasets, but given the smaller scale of this application, it provides the best balance between usability and performance. To maintain efficiency, I had the database perform most of the filtering, as opposed to the application layer. 

This enhancement aligns mostly with course outcomes 3 and 4. I demonstrate outcome 3 through the design and implementation of an algorithmic solution while outcome 4 is demonstrated through using regex filtering for data retrieval. To a lesser extent, outcome 5 is demonstrated through secure coding practices while handling input and database queriend. For the user experience, the ability to search makes inventory management faster and more intuitive. By being able to type partial SKUs, users can easily locate items, reducing the need to manually scroll through potentially large lists. 

This enhancement was actually a bit easier than I was initially anticipating. However, I did get to learn more about how algorithms interact with data structures in practical software. Additionally, I learned how design choices can directly affect performance as well as the importance of secure handling of input data (even in seemingly simple features). This experience definitely helped build my problem-solving and debugging skills, helping me be ready to handle real-world software concerns where efficiency, security, and design all need to be taken into consideration.

## Enhancement Three: Databases
For this enhancement, I designed a MongoDB database that supported the same basic functionality as the basic SQLite database I implemented for the Android Inventory App. This MongoDB backend supports full CRUD (create, read, update, and delete) functionality, user account creation, and secure access controls that restrict system operations until successful login. The original artifact demonstrated my ability to create a simple SQLite database for mobile application use, where the enhanced version showcases my ability to design robust, scalabel, and secure database-driven applications. 

This enhancement aligns mostly with outcomes 4 and 5. I achieved outcome 4 by implementing secure and efficient database operations through parameterized queries, enforcing unique SKU constraints, and thorough input validation. I demonstrated outcome 5 through structure logging and strong exception handling. While my initial plan included building a complete transaction log for tracking all CRUD transactions, I found that impementing a reliable multi-user tracking system was far more complev than I had anticipated. I plan to integrate this in future iterations should I continue to tweak this project further in the future. 

MongoDB was a fairly easy choice for a database for this project, since it's document-based storage model give more flexibility when managing item data and user records, allowing for easy schema evolution without the need to restructure an entire table. Querying large collections became more efficient, since MongoDB supports indexing and aggregation pipelines. During development, I faced quite a few challenges. Java's SQLite interface was much simpler than working in C++ with the mongocxx driver, requiring explicit exception management, resource allocation, and type safety. Any MongoDB operation could throw a distinct exception, so careful validation of user inputs before type conversation as well as strong error checking was entirely necessary. Through this process, I learned to think defensively about each possible point of failure and to write code that anticipates errors, rather than just reacting to them.
